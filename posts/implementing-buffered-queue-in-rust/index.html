<!doctype html><html><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Implementing a Naive Buffered Queue in Rust
        
    </title><meta content="Implementing a Naive Buffered Queue in Rust" property=og:title><meta content="Writing a custom implementation of a simple blocking, buffered queue in Rust" property=og:description><meta content="Writing a custom implementation of a simple blocking, buffered queue in Rust" name=description><link href=https://dhruvahuja.me/fonts.css rel=stylesheet><script async data-goatcounter=https://dhruv-ahuja.goatcounter.com/count src=https://dhruvahuja.me/js/count.js></script><noscript><img src="https://dhruv-ahuja.goatcounter.com//count?p=/posts/implementing-buffered-queue-in-rust/&t=Implementing a Naive Buffered Queue in Rust"></noscript><link href=https://dhruvahuja.me/atom.xml rel=alternate title=dhruv-ahuja type=application/atom+xml><link href=https://dhruvahuja.me/main.css media=screen rel=stylesheet><link href=https://dhruvahuja.me/theme/light.css rel=stylesheet><link media="(prefers-color-scheme: dark)" href=https://dhruvahuja.me/theme/dark.css rel=stylesheet><script src=https://dhruvahuja.me/js/feather.min.js></script><body><div class=content><header><div class=main><a href=https://dhruvahuja.me>dhruv-ahuja</a><div class=socials><a class=social href=mailto:dhruvahuja2k@gmail.com rel=me target=_blank> <img alt=email src=/social_icons/email.svg> </a><a class=social href=https://www.linkedin.com/in/dhruvahuja2k/ rel=me target=_blank> <img alt=linkedin src=/social_icons/linkedin.svg> </a><a class=social href=https://github.com/dhruv-ahuja/ rel=me target=_blank> <img alt=github src=/social_icons/github.svg> </a></div></div><nav><a href=/posts style=margin-left:.7em>/posts</a><a href=/projects style=margin-left:.7em>/projects</a> | <a href id=dark-mode-toggle onclick=toggleTheme()></a><script src=https://dhruvahuja.me/js/themetoggle.js></script></nav></header><main><article><div class=title><div class=page-header>Implementing a Naive Buffered Queue in Rust<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>06-09-2023</time></div></div><section class=body><h2 id=introduction>Introduction</h2><p>O’Reilly’s <code>Programming Rust</code> book walks us through optimizing a part of a pipeline, in Chapter 19 <code>Concurrency</code>. It explains how a channel-based pipeline can encounter slowdowns and high memory usage if one of the consumer threads is much slower than one of the producer threads. The producer keeps adding tasks to the queue, but the consumer is unable to consume them at a satisfactory pace. The queue will have a large amount of unconsumed data causing memory spikes. Defining fixed capacities will lower memory consumption in applications without affecting the latencies since the consumer already consumes at its own fixed pace.<p>I had known about queues but had never thought about them in a larger scope, so I thought attempting a custom implementation would be a good way to learn more. I received a lot of help from the Rust community for this project, allowing me to better understand the concepts and improve my code :)  <h2 id=overview>Overview</h2><p>We will walk through the implementation of a simple multi-threaded, blocking, buffered queue. The Producer thread will push elements till the queue is at capacity, and block until the queue has space again. Similarly, the Consumer thread will consume elements till the queue is empty, and block until it has elements again. We do not persist the threads once the input stream is expended.<h2 id=declaring-our-types>Declaring our Types</h2><p>We can create a new project with <code>cargo new buffered-queue-rs</code> and put our queue logic in <code>src/lib.rs</code>, marking all code inside the file as library code. This makes it accessible to the whole project by importing it with the project name specified in the <code>cargo new</code> command.<p>Add the following imports to the file:<pre class=language-rust data-lang=rust style=background:#212121;color:#eeffff><code class=language-rust data-lang=rust><span style=color:#c792ea>use </span><span>std</span><span style=color:#89ddff>::</span><span>collections</span><span style=color:#89ddff>::</span><span>VecDeque</span><span style=color:#89ddff>;
</span><span style=color:#c792ea>use </span><span>std</span><span style=color:#89ddff>::</span><span>sync</span><span style=color:#89ddff>::</span><span>atomic</span><span style=color:#89ddff>::{</span><span>AtomicBool</span><span style=color:#89ddff>,</span><span> Ordering</span><span style=color:#89ddff>};
</span><span style=color:#c792ea>use </span><span>std</span><span style=color:#89ddff>::</span><span>sync</span><span style=color:#89ddff>::{</span><span>Arc</span><span style=color:#89ddff>,</span><span> Condvar</span><span style=color:#89ddff>,</span><span> Mutex</span><span style=color:#89ddff>,</span><span> MutexGuard</span><span style=color:#89ddff>};
</span></code></pre><p>Next, we will define the types for our buffered queue implementation:<pre class=language-rust data-lang=rust style=background:#212121;color:#eeffff><code class=language-rust data-lang=rust><span style=color:#c792ea>pub </span><span style=font-style:italic;color:#c792ea>struct </span><span>Producer</span><span style=color:#89ddff><</span><span>T</span><span style=color:#89ddff>>(</span><span>Arc</span><span style=color:#89ddff><</span><span>BufferedQueue</span><span style=color:#89ddff><</span><span>T</span><span style=color:#89ddff>>>);
</span><span>
</span><span style=color:#c792ea>pub </span><span style=font-style:italic;color:#c792ea>struct </span><span>Consumer</span><span style=color:#89ddff><</span><span>T</span><span style=color:#89ddff>>(</span><span>Arc</span><span style=color:#89ddff><</span><span>BufferedQueue</span><span style=color:#89ddff><</span><span>T</span><span style=color:#89ddff>>>);
</span><span>
</span><span style=color:#c792ea>pub </span><span style=font-style:italic;color:#c792ea>struct </span><span>BufferedQueue</span><span style=color:#89ddff><</span><span>T</span><span style=color:#89ddff>> {
</span><span>    data</span><span style=color:#89ddff>: </span><span>Mutex</span><span style=color:#89ddff><</span><span>VecDeque</span><span style=color:#89ddff><</span><span>T</span><span style=color:#89ddff>>></span><span>,
</span><span>    </span><span style=color:#c792ea>pub </span><span>capacity</span><span style=color:#89ddff>: </span><span style=font-style:italic;color:#c792ea>usize</span><span>,
</span><span>    </span><span style=color:#c792ea>pub </span><span>is_full</span><span style=color:#89ddff>: </span><span>Mutex</span><span style=color:#89ddff><</span><span style=font-style:italic;color:#c792ea>bool</span><span style=color:#89ddff>></span><span>,
</span><span>    </span><span style=color:#c792ea>pub </span><span>is_full_signal</span><span style=color:#89ddff>:</span><span> Condvar,
</span><span>    </span><span style=color:#c792ea>pub </span><span>is_empty</span><span style=color:#89ddff>: </span><span>Mutex</span><span style=color:#89ddff><</span><span style=font-style:italic;color:#c792ea>bool</span><span style=color:#89ddff>></span><span>,
</span><span>    </span><span style=color:#c792ea>pub </span><span>is_empty_signal</span><span style=color:#89ddff>:</span><span> Condvar,
</span><span>    </span><span style=color:#c792ea>pub </span><span>elements_processed</span><span style=color:#89ddff>:</span><span> AtomicBool,
</span><span style=color:#89ddff>}
</span></code></pre><p>These are <a href=https://doc.rust-lang.org/book/ch10-01-syntax.html title=https://doc.rust-lang.org/book/ch10-01-syntax.html>generic</a> types, signified by the type parameter <code>&LTT></code>, and can be used with any type as we have not defined any constraints on the type <code>T</code>.<p><code>Producer</code> and <code>Consumer</code> follow the <a href=https://rust-unofficial.github.io/patterns/patterns/behavioural/newtype.html title=https://rust-unofficial.github.io/patterns/patterns/behavioural/newtype.html>NewType</a> pattern, allowing us to specify special behaviour on the wrapped type. It will help us separate producer and consumer concerns.<p>All the defined types use an <a href=https://doc.rust-lang.org/std/sync/struct.Arc.html title=https://doc.rust-lang.org/std/sync/struct.Arc.html>Arc</a>, a special pointer type that enables cheap shared access to data. It also allows sharing its pointer values across threads, even though the wrapped value might not be shareable. It maintains a reference counter for each reference active in memory, similar to Python objects.<p>Our internal queue implementation <code>data</code> is a double-ended queue, held by a mutex to prevent data inconsistencies and enforce exclusive data access. <code>capacity</code> is the user-defined maximum capacity for our queue. <code>usize</code> data type ensures that the value cannot be negative. <code>is_full</code> and <code>is_empty</code> indicate the queue’s current state. They will be used by the <code>is_full_signal</code> and <code>is_empty_signal</code> <a href=https://doc.rust-lang.org/std/sync/struct.Condvar.html title=https://doc.rust-lang.org/std/sync/struct.Condvar.html>Condvars</a> to allow the producer and consumer threads to wait until the queue is in their desired state. <code>elements_processed</code> is an <a href=https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html title=https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html>AtomicBool</a> and is thread-safe.  <p>The <code>Operation</code> enum type will signal the queue’s state updates to listening threads. It maps to the queue’s push and pop operations:<pre class=language-rust data-lang=rust style=background:#212121;color:#eeffff><code class=language-rust data-lang=rust><span style=font-style:italic;color:#c792ea>enum </span><span>Operation<'a> </span><span style=color:#89ddff>{
</span><span>    Push </span><span style=color:#89ddff>{</span><span> is_full_flag</span><span style=color:#89ddff>: </span><span>MutexGuard</span><span style=color:#89ddff><</span><span style=color:#c792ea>'a</span><span>, </span><span style=font-style:italic;color:#c792ea>bool</span><span style=color:#89ddff>> },
</span><span>    Pop </span><span style=color:#89ddff>{</span><span> is_empty_flag</span><span style=color:#89ddff>: </span><span>MutexGuard</span><span style=color:#89ddff><</span><span style=color:#c792ea>'a</span><span>, </span><span style=font-style:italic;color:#c792ea>bool</span><span style=color:#89ddff>> },
</span><span style=color:#89ddff>}
</span></code></pre><p>Acquiring the lock on a mutex returns a <a href=https://doc.rust-lang.org/std/sync/struct.MutexGuard.html title=https://doc.rust-lang.org/std/sync/struct.MutexGuard.html>MutexGuard</a>, a thin wrapper around the value held by the mutex. The <a href=https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html title=https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html>lifetime specifier</a> <code><’a></code>  in the type definition indicates how long the boolean flags are going to stay in memory. They are now associated with the enum variants and their held locks will be unlocked when the enum variants go out of scope.<p>We can see Rust’s powerful enums here, as we can add data on individual variants like we would with a struct.<h2 id=defining-producer-and-consumer-logic>Defining Producer and Consumer Logic</h2><p>Producer and consumer have a similar logical flow. Both have 2 methods, the <code>len</code> method is common to both types and wraps a call to <code>BufferedQueue</code>‘s <code>len</code> method.  <h3 id=producer>Producer</h3><p>Producer’s implementation is:<pre class=language-rust data-lang=rust style=background:#212121;color:#eeffff><code class=language-rust data-lang=rust><span style=font-style:italic;color:#c792ea>impl</span><span style=color:#89ddff><</span><span>T</span><span style=color:#89ddff>> </span><span>Producer</span><span style=color:#89ddff><</span><span>T</span><span style=color:#89ddff>> {
</span><span>    </span><span style=color:#c792ea>pub </span><span style=font-style:italic;color:#c792ea>fn </span><span style=color:#82aaff>push</span><span style=color:#89ddff>(&</span><span style=color:#f78c6c>self</span><span>, </span><span style=color:#f78c6c>value</span><span style=color:#89ddff>:</span><span> T</span><span style=color:#89ddff>) {
</span><span>        </span><span style=font-style:italic;color:#c792ea>let </span><span style=color:#c792ea>mut</span><span> queue_is_full </span><span style=color:#89ddff>= </span><span style=font-style:italic;color:#ff5370>self</span><span style=color:#89ddff>.</span><span style=color:#f78c6c>0.</span><span>is_full</span><span style=color:#89ddff>.</span><span style=color:#82aaff>lock</span><span style=color:#89ddff>().</span><span style=color:#82aaff>unwrap</span><span style=color:#89ddff>();
</span><span>        </span><span style=font-style:italic;color:#c792ea>while </span><span style=color:#89ddff>*</span><span>queue_is_full </span><span style=color:#89ddff>{
</span><span>            queue_is_full </span><span style=color:#89ddff>= </span><span style=font-style:italic;color:#ff5370>self</span><span style=color:#89ddff>.</span><span style=color:#f78c6c>0.</span><span>is_full_signal</span><span style=color:#89ddff>.</span><span style=color:#82aaff>wait</span><span style=color:#89ddff>(</span><span>queue_is_full</span><span style=color:#89ddff>).</span><span style=color:#82aaff>unwrap</span><span style=color:#89ddff>();
</span><span>        </span><span style=color:#89ddff>}
</span><span>
</span><span>        </span><span style=font-style:italic;color:#c792ea>let </span><span style=color:#c792ea>mut</span><span> queue </span><span style=color:#89ddff>= </span><span style=font-style:italic;color:#ff5370>self</span><span style=color:#89ddff>.</span><span style=color:#f78c6c>0.</span><span>data</span><span style=color:#89ddff>.</span><span style=color:#82aaff>lock</span><span style=color:#89ddff>().</span><span style=color:#82aaff>unwrap</span><span style=color:#89ddff>();
</span><span>        queue</span><span style=color:#89ddff>.</span><span style=color:#82aaff>push_back</span><span style=color:#89ddff>(</span><span>value</span><span style=color:#89ddff>);
</span><span>        println!</span><span style=color:#89ddff>("</span><span style=color:#c3e88d>pushed element</span><span style=color:#89ddff>");
</span><span>
</span><span>        </span><span style=font-style:italic;color:#ff5370>self</span><span style=color:#89ddff>.</span><span style=color:#f78c6c>0.</span><span style=color:#82aaff>signal_queue_changes</span><span style=color:#89ddff>(
</span><span>            queue</span><span style=color:#89ddff>,
</span><span>            Operation</span><span style=color:#89ddff>::</span><span>Push </span><span style=color:#89ddff>{
</span><span>                is_full_flag</span><span style=color:#89ddff>:</span><span> queue_is_full</span><span style=color:#89ddff>,
</span><span>            </span><span style=color:#89ddff>},
</span><span>        </span><span style=color:#89ddff>);
</span><span>    </span><span style=color:#89ddff>}
</span><span>
</span><span>    </span><span style=color:#c792ea>pub </span><span style=font-style:italic;color:#c792ea>fn </span><span style=color:#82aaff>len</span><span style=color:#89ddff>(&</span><span style=color:#f78c6c>self</span><span style=color:#89ddff>) -> </span><span style=font-style:italic;color:#c792ea>usize </span><span style=color:#89ddff>{
</span><span>        </span><span style=font-style:italic;color:#ff5370>self</span><span style=color:#89ddff>.</span><span style=color:#f78c6c>0.</span><span style=color:#82aaff>len</span><span style=color:#89ddff>()
</span><span>    </span><span style=color:#89ddff>}
</span><span style=color:#89ddff>}
</span></code></pre><p><code>self.0</code> accesses the Producer’s first value in the tuple – the buffered queue Arc, to access its fields and methods.<p>We first get the <code>queue_is_full</code> boolean value and check whether the queue is full. Code execution will be paused until the queue has space and <code>queue_is_full</code> equals <code>false</code>. The <code>wait</code> method takes a MutexGuard and atomically releases the lock. This enables other threads to update its value. It re-acquires the lock before returning.<p>We access the internal queue if there is space, push the new element and call the <code>signal_queue_changes</code> method that we will define on <code>BufferedQueue</code> later.<p>We will also implement the <a href=https://doc.rust-lang.org/rust-by-example/trait/drop.html title=https://doc.rust-lang.org/rust-by-example/trait/drop.html>Drop</a> trait, which will perform cleanup after our producer is out of scope:<pre class=language-rust data-lang=rust style=background:#212121;color:#eeffff><code class=language-rust data-lang=rust><span style=font-style:italic;color:#c792ea>impl</span><span style=color:#89ddff><</span><span>T</span><span style=color:#89ddff>></span><span> Drop </span><span style=color:#c792ea>for </span><span>Producer</span><span style=color:#89ddff><</span><span>T</span><span style=color:#89ddff>> {
</span><span>    </span><span style=font-style:italic;color:#c792ea>fn </span><span style=color:#82aaff>drop</span><span style=color:#89ddff>(&</span><span style=color:#c792ea>mut </span><span style=color:#f78c6c>self</span><span style=color:#89ddff>) {
</span><span>        </span><span style=font-style:italic;color:#ff5370>self</span><span style=color:#89ddff>.</span><span style=color:#f78c6c>0.</span><span>elements_processed</span><span style=color:#89ddff>.</span><span style=color:#82aaff>store</span><span style=color:#89ddff>(</span><span style=color:#f78c6c>true</span><span style=color:#89ddff>, </span><span>Ordering</span><span style=color:#89ddff>::</span><span>SeqCst</span><span style=color:#89ddff>);
</span><span>    </span><span style=color:#89ddff>}
</span><span style=color:#89ddff>}
</span></code></pre><p>We set <code>elements_processed</code> value to <code>true</code>, indicating that the producer has processed all its elements and is going out of scope. The <code>Drop</code> trait ensures that this implementation detail remains associated with the producer.<p>The <code>store</code> method requires a memory ordering, which defines how application memory is organized and ensures that our code avoids race conditions and improper data access across threads. We use the strongest possible ordering, <code>SeqCst</code>.<h3 id=consumer>Consumer</h3><p>Consumer’s methods are as follows:<pre class=language-rust data-lang=rust style=background:#212121;color:#eeffff><code class=language-rust data-lang=rust><span style=font-style:italic;color:#c792ea>impl</span><span style=color:#89ddff><</span><span>T</span><span style=color:#89ddff>> </span><span>Consumer</span><span style=color:#89ddff><</span><span>T</span><span style=color:#89ddff>> {
</span><span>    </span><span style=color:#c792ea>pub </span><span style=font-style:italic;color:#c792ea>fn </span><span style=color:#82aaff>pop</span><span style=color:#89ddff>(&</span><span style=color:#f78c6c>self</span><span style=color:#89ddff>) -> </span><span style=color:#ffcb6b>Option</span><span style=color:#89ddff><</span><span>T</span><span style=color:#89ddff>> {
</span><span>        </span><span style=font-style:italic;color:#c792ea>let </span><span style=color:#c792ea>mut</span><span> queue_is_empty </span><span style=color:#89ddff>= </span><span style=font-style:italic;color:#ff5370>self</span><span style=color:#89ddff>.</span><span style=color:#f78c6c>0.</span><span>is_empty</span><span style=color:#89ddff>.</span><span style=color:#82aaff>lock</span><span style=color:#89ddff>().</span><span style=color:#82aaff>unwrap</span><span style=color:#89ddff>();
</span><span>        </span><span style=font-style:italic;color:#c792ea>while </span><span style=color:#89ddff>*</span><span>queue_is_empty </span><span style=color:#89ddff>{
</span><span>            </span><span style=font-style:italic;color:#c792ea>if </span><span style=font-style:italic;color:#ff5370>self</span><span style=color:#89ddff>.</span><span style=color:#f78c6c>0.</span><span>elements_processed</span><span style=color:#89ddff>.</span><span style=color:#82aaff>load</span><span style=color:#89ddff>(</span><span>Ordering</span><span style=color:#89ddff>::</span><span>SeqCst</span><span style=color:#89ddff>) {
</span><span>                </span><span style=font-style:italic;color:#c792ea>return </span><span style=color:#ffcb6b>None</span><span style=color:#89ddff>;
</span><span>            </span><span style=color:#89ddff>}
</span><span>            queue_is_empty </span><span style=color:#89ddff>= </span><span style=font-style:italic;color:#ff5370>self</span><span style=color:#89ddff>.</span><span style=color:#f78c6c>0.</span><span>is_empty_signal</span><span style=color:#89ddff>.</span><span style=color:#82aaff>wait</span><span style=color:#89ddff>(</span><span>queue_is_empty</span><span style=color:#89ddff>).</span><span style=color:#82aaff>unwrap</span><span style=color:#89ddff>();
</span><span>        </span><span style=color:#89ddff>}
</span><span>
</span><span>        </span><span style=font-style:italic;color:#c792ea>let </span><span style=color:#c792ea>mut</span><span> queue </span><span style=color:#89ddff>= </span><span style=font-style:italic;color:#ff5370>self</span><span style=color:#89ddff>.</span><span style=color:#f78c6c>0.</span><span>data</span><span style=color:#89ddff>.</span><span style=color:#82aaff>lock</span><span style=color:#89ddff>().</span><span style=color:#82aaff>unwrap</span><span style=color:#89ddff>();
</span><span>        </span><span style=font-style:italic;color:#c792ea>let</span><span> popped_element </span><span style=color:#89ddff>=</span><span> queue</span><span style=color:#89ddff>.</span><span style=color:#82aaff>pop_front</span><span style=color:#89ddff>();
</span><span>        println!</span><span style=color:#89ddff>("</span><span style=color:#c3e88d>popped element</span><span style=color:#89ddff>");
</span><span>
</span><span>        </span><span style=font-style:italic;color:#ff5370>self</span><span style=color:#89ddff>.</span><span style=color:#f78c6c>0.</span><span style=color:#82aaff>signal_queue_changes</span><span style=color:#89ddff>(
</span><span>            queue</span><span style=color:#89ddff>,
</span><span>            Operation</span><span style=color:#89ddff>::</span><span>Pop </span><span style=color:#89ddff>{
</span><span>                is_empty_flag</span><span style=color:#89ddff>:</span><span> queue_is_empty</span><span style=color:#89ddff>,
</span><span>            </span><span style=color:#89ddff>},
</span><span>        </span><span style=color:#89ddff>);
</span><span>        popped_element
</span><span>    </span><span style=color:#89ddff>}
</span><span>
</span><span>    </span><span style=color:#c792ea>pub </span><span style=font-style:italic;color:#c792ea>fn </span><span style=color:#82aaff>len</span><span style=color:#89ddff>(&</span><span style=color:#f78c6c>self</span><span style=color:#89ddff>) -> </span><span style=font-style:italic;color:#c792ea>usize </span><span style=color:#89ddff>{
</span><span>        </span><span style=font-style:italic;color:#ff5370>self</span><span style=color:#89ddff>.</span><span style=color:#f78c6c>0.</span><span style=color:#82aaff>len</span><span style=color:#89ddff>()
</span><span>    </span><span style=color:#89ddff>}
</span><span style=color:#89ddff>}
</span></code></pre><p><code>pop</code> returns an <code>Option&LTT></code> meaning it will return an enum variant <code>Some(T)</code> from the front of the queue, or <code>None</code> if the queue is empty. We wait for the producer to add elements if the queue is currently empty.<p>Our implementation guarantees that the queue will only pop an element from front of the queue if there is at least one element. We only return <code>None</code> once <code>elements_processed</code> is <code>true</code>, signalling that we can finish our execution.<h2 id=defining-bufferedqueue-logic>Defining BufferedQueue Logic</h2><p>We will first write a function to create a new buffered queue:<pre class=language-rust data-lang=rust style=background:#212121;color:#eeffff><code class=language-rust data-lang=rust><span style=color:#c792ea>pub </span><span style=font-style:italic;color:#c792ea>fn </span><span style=color:#82aaff>buffered_queue</span><span style=color:#89ddff><</span><span>T</span><span style=color:#89ddff>>(</span><span style=color:#c792ea>mut </span><span style=color:#f78c6c>capacity</span><span style=color:#89ddff>: </span><span style=font-style:italic;color:#c792ea>usize</span><span style=color:#89ddff>) -> (</span><span>Producer</span><span style=color:#89ddff><</span><span>T</span><span style=color:#89ddff>></span><span>, Consumer</span><span style=color:#89ddff><</span><span>T</span><span style=color:#89ddff>>) {
</span><span>    </span><span style=font-style:italic;color:#c792ea>if</span><span> capacity </span><span style=color:#89ddff>< </span><span style=color:#f78c6c>1 </span><span style=color:#89ddff>{
</span><span>        eprintln!</span><span style=color:#89ddff>("</span><span style=color:#c3e88d>capacity cannot be lower than 1, defaulting to 1...</span><span style=color:#89ddff>");
</span><span>        capacity </span><span style=color:#89ddff>= </span><span style=color:#f78c6c>1
</span><span>    </span><span style=color:#89ddff>}
</span><span>
</span><span>    </span><span style=font-style:italic;color:#c792ea>let</span><span> buffered_queue </span><span style=color:#89ddff>=</span><span> BufferedQueue </span><span style=color:#89ddff>{
</span><span>        data</span><span style=color:#89ddff>: </span><span>Mutex</span><span style=color:#89ddff>::</span><span>new</span><span style=color:#89ddff>(</span><span>VecDeque</span><span style=color:#89ddff>::</span><span>with_capacity</span><span style=color:#89ddff>(</span><span>capacity</span><span style=color:#89ddff>)),
</span><span>        capacity</span><span style=color:#89ddff>,
</span><span>        is_full</span><span style=color:#89ddff>: </span><span>Mutex</span><span style=color:#89ddff>::</span><span>new</span><span style=color:#89ddff>(</span><span style=color:#f78c6c>false</span><span style=color:#89ddff>),
</span><span>        is_empty</span><span style=color:#89ddff>: </span><span>Mutex</span><span style=color:#89ddff>::</span><span>new</span><span style=color:#89ddff>(</span><span style=color:#f78c6c>true</span><span style=color:#89ddff>),
</span><span>        is_full_signal</span><span style=color:#89ddff>: </span><span>Condvar</span><span style=color:#89ddff>::</span><span>new</span><span style=color:#89ddff>(),
</span><span>        is_empty_signal</span><span style=color:#89ddff>: </span><span>Condvar</span><span style=color:#89ddff>::</span><span>new</span><span style=color:#89ddff>(),
</span><span>        elements_processed</span><span style=color:#89ddff>: </span><span>AtomicBool</span><span style=color:#89ddff>::</span><span>new</span><span style=color:#89ddff>(</span><span style=color:#f78c6c>false</span><span style=color:#89ddff>),
</span><span>    </span><span style=color:#89ddff>};
</span><span>
</span><span>    </span><span style=font-style:italic;color:#c792ea>let</span><span> data </span><span style=color:#89ddff>= </span><span>Arc</span><span style=color:#89ddff>::</span><span>new</span><span style=color:#89ddff>(</span><span>buffered_queue</span><span style=color:#89ddff>);
</span><span>    </span><span style=font-style:italic;color:#c792ea>let</span><span> producer </span><span style=color:#89ddff>=</span><span> Producer</span><span style=color:#89ddff>(</span><span>data</span><span style=color:#89ddff>.</span><span style=color:#82aaff>clone</span><span style=color:#89ddff>());
</span><span>    </span><span style=font-style:italic;color:#c792ea>let</span><span> consumer </span><span style=color:#89ddff>=</span><span> Consumer</span><span style=color:#89ddff>(</span><span>data</span><span style=color:#89ddff>);
</span><span>
</span><span>    </span><span style=color:#89ddff>(</span><span>producer</span><span style=color:#89ddff>,</span><span> consumer</span><span style=color:#89ddff>)
</span><span style=color:#89ddff>}
</span></code></pre><p><code>buffered_queue</code> takes a capacity and returns a tuple of Producer and Consumer types. It uses 1 as default if the capacity is 0, wraps the buffered queue value in Arc for cheap referencing and thread-safety, makes a reference copy and passes the Arc instances to Producer and Consumer types.<p>Now we will implement its methods:<pre class=language-rust data-lang=rust style=background:#212121;color:#eeffff><code class=language-rust data-lang=rust><span style=font-style:italic;color:#c792ea>impl</span><span style=color:#89ddff><</span><span>T</span><span style=color:#89ddff>> </span><span>BufferedQueue</span><span style=color:#89ddff><</span><span>T</span><span style=color:#89ddff>> {
</span><span>    </span><span style=font-style:italic;color:#c792ea>fn </span><span style=color:#82aaff>len</span><span style=color:#89ddff>(&</span><span style=color:#f78c6c>self</span><span style=color:#89ddff>) -> </span><span style=font-style:italic;color:#c792ea>usize </span><span style=color:#89ddff>{
</span><span>        </span><span style=font-style:italic;color:#c792ea>let</span><span> queue </span><span style=color:#89ddff>= </span><span style=font-style:italic;color:#ff5370>self</span><span style=color:#89ddff>.</span><span>data</span><span style=color:#89ddff>.</span><span style=color:#82aaff>lock</span><span style=color:#89ddff>().</span><span style=color:#82aaff>unwrap</span><span style=color:#89ddff>();
</span><span>        queue</span><span style=color:#89ddff>.</span><span style=color:#82aaff>len</span><span style=color:#89ddff>()
</span><span>    </span><span style=color:#89ddff>}
</span><span>
</span><span>    </span><span style=font-style:italic;color:#c792ea>fn </span><span style=color:#82aaff>signal_queue_changes</span><span style=color:#89ddff>(&</span><span style=color:#f78c6c>self</span><span>, </span><span style=color:#f78c6c>queue</span><span style=color:#89ddff>: </span><span>MutexGuard</span><span style=color:#89ddff><</span><span>'</span><span style=color:#89ddff>_</span><span>, VecDeque</span><span style=color:#89ddff><</span><span>T</span><span style=color:#89ddff>>></span><span>, </span><span style=color:#f78c6c>operation</span><span style=color:#89ddff>:</span><span> Operation</span><span style=color:#89ddff>) {
</span><span>        </span><span style=font-style:italic;color:#c792ea>let</span><span> is_empty </span><span style=color:#89ddff>=</span><span> queue</span><span style=color:#89ddff>.</span><span style=color:#82aaff>len</span><span style=color:#89ddff>() == </span><span style=color:#f78c6c>0</span><span style=color:#89ddff>;
</span><span>        </span><span style=font-style:italic;color:#c792ea>let</span><span> is_full </span><span style=color:#89ddff>=</span><span> queue</span><span style=color:#89ddff>.</span><span style=color:#82aaff>len</span><span style=color:#89ddff>() == </span><span style=font-style:italic;color:#ff5370>self</span><span style=color:#89ddff>.</span><span>capacity</span><span style=color:#89ddff>;
</span><span>
</span><span>        </span><span style=font-style:italic;color:#c792ea>match</span><span> operation </span><span style=color:#89ddff>{
</span><span>            Operation</span><span style=color:#89ddff>::</span><span>Push </span><span style=color:#89ddff>{ </span><span style=color:#c792ea>mut</span><span> is_full_flag </span><span style=color:#89ddff>} => {
</span><span>                </span><span style=font-style:italic;color:#c792ea>let </span><span style=color:#c792ea>mut</span><span> is_empty_flag </span><span style=color:#89ddff>= </span><span style=font-style:italic;color:#ff5370>self</span><span style=color:#89ddff>.</span><span>is_empty</span><span style=color:#89ddff>.</span><span style=color:#82aaff>lock</span><span style=color:#89ddff>().</span><span style=color:#82aaff>unwrap</span><span style=color:#89ddff>();
</span><span>                </span><span style=font-style:italic;color:#c792ea>if </span><span style=color:#89ddff>*</span><span>is_empty_flag </span><span style=color:#89ddff>{
</span><span>                    </span><span style=color:#89ddff>*</span><span>is_empty_flag </span><span style=color:#89ddff>= </span><span style=color:#f78c6c>false</span><span style=color:#89ddff>;
</span><span>                    println!</span><span style=color:#89ddff>("</span><span style=color:#c3e88d>set is_empty to false</span><span style=color:#89ddff>");
</span><span>                    </span><span style=font-style:italic;color:#ff5370>self</span><span style=color:#89ddff>.</span><span>is_empty_signal</span><span style=color:#89ddff>.</span><span style=color:#82aaff>notify_all</span><span style=color:#89ddff>();
</span><span>                </span><span style=color:#89ddff>}
</span><span>
</span><span>                </span><span style=font-style:italic;color:#c792ea>if</span><span> is_full </span><span style=color:#89ddff>{
</span><span>                    </span><span style=color:#89ddff>*</span><span>is_full_flag </span><span style=color:#89ddff>= </span><span style=color:#f78c6c>true</span><span style=color:#89ddff>;
</span><span>                    </span><span style=font-style:italic;color:#ff5370>self</span><span style=color:#89ddff>.</span><span>is_full_signal</span><span style=color:#89ddff>.</span><span style=color:#82aaff>notify_all</span><span style=color:#89ddff>();
</span><span>                    println!</span><span style=color:#89ddff>("</span><span style=color:#c3e88d>set is_full to true</span><span style=color:#89ddff>");
</span><span>                </span><span style=color:#89ddff>}
</span><span>            </span><span style=color:#89ddff>}
</span><span>
</span><span>            Operation</span><span style=color:#89ddff>::</span><span>Pop </span><span style=color:#89ddff>{ </span><span style=color:#c792ea>mut</span><span> is_empty_flag </span><span style=color:#89ddff>} => {
</span><span>                </span><span style=font-style:italic;color:#c792ea>let </span><span style=color:#c792ea>mut</span><span> is_full_flag </span><span style=color:#89ddff>= </span><span style=font-style:italic;color:#ff5370>self</span><span style=color:#89ddff>.</span><span>is_full</span><span style=color:#89ddff>.</span><span style=color:#82aaff>lock</span><span style=color:#89ddff>().</span><span style=color:#82aaff>unwrap</span><span style=color:#89ddff>();
</span><span>                </span><span style=font-style:italic;color:#c792ea>if </span><span style=color:#89ddff>*</span><span>is_full_flag </span><span style=color:#89ddff>{
</span><span>                    </span><span style=color:#89ddff>*</span><span>is_full_flag </span><span style=color:#89ddff>= </span><span style=color:#f78c6c>false</span><span style=color:#89ddff>;
</span><span>                    println!</span><span style=color:#89ddff>("</span><span style=color:#c3e88d>set is_full to false</span><span style=color:#89ddff>");
</span><span>                    </span><span style=font-style:italic;color:#ff5370>self</span><span style=color:#89ddff>.</span><span>is_full_signal</span><span style=color:#89ddff>.</span><span style=color:#82aaff>notify_all</span><span style=color:#89ddff>();
</span><span>                </span><span style=color:#89ddff>}
</span><span>
</span><span>                </span><span style=font-style:italic;color:#c792ea>if</span><span> is_empty </span><span style=color:#89ddff>{
</span><span>                    </span><span style=color:#89ddff>*</span><span>is_empty_flag </span><span style=color:#89ddff>= </span><span style=color:#f78c6c>true</span><span style=color:#89ddff>;
</span><span>                    </span><span style=font-style:italic;color:#ff5370>self</span><span style=color:#89ddff>.</span><span>is_empty_signal</span><span style=color:#89ddff>.</span><span style=color:#82aaff>notify_all</span><span style=color:#89ddff>();
</span><span>                    println!</span><span style=color:#89ddff>("</span><span style=color:#c3e88d>set is_empty to true</span><span style=color:#89ddff>");
</span><span>                </span><span style=color:#89ddff>}
</span><span>            </span><span style=color:#89ddff>}
</span><span>        </span><span style=color:#89ddff>}
</span><span>    </span><span style=color:#89ddff>}
</span><span style=color:#89ddff>}
</span></code></pre><p>This method accepts the internal queue and operation enum types. <code>queue</code> defines the double-ended queue value after acquiring its mutex lock.<p>We match the operation variants and define their associated boolean values as mutable. Rust allows us to shorthand values if the variable name matches the field name, so we can write <code>{ mut is_full_flag: is_full_flag }</code> as  <code>{ mut is_full_flag }</code> and so on.<p>The method checks whether the queue’s state has changed: after an element <code>Push</code>, whether the queue is now full and whether it was empty earlier, after an element <code>Pop</code>, whether the queue is now empty and whether it was full before. It notifies waiting threads on the state changes if these conditions match, by calling the Condvars’ <code>notify_all</code> method.<h3 id=testing-things-out>Testing Things Out</h3><p>We can now test the functionality by creating a small simulation.<p>Add the following imports to the top of the <code>src/main.rs</code> file:<pre class=language-rust data-lang=rust style=background:#212121;color:#eeffff><code class=language-rust data-lang=rust><span style=color:#c792ea>use </span><span>buffered_queue_rs</span><span style=color:#89ddff>::</span><span>buffered_queue</span><span style=color:#89ddff>;
</span><span style=color:#c792ea>use </span><span>std</span><span style=color:#89ddff>::</span><span>thread</span><span style=color:#89ddff>::{</span><span style=font-style:italic;color:#ff5370>self</span><span style=color:#89ddff>,</span><span> sleep</span><span style=color:#89ddff>};
</span><span style=color:#c792ea>use </span><span>std</span><span style=color:#89ddff>::</span><span>time</span><span style=color:#89ddff>::</span><span>Duration</span><span style=color:#89ddff>;
</span></code></pre><p>Write the following code in the <code>src/main.rs</code> file and replace the existing <code>main</code> function:<pre class=language-rust data-lang=rust style=background:#212121;color:#eeffff><code class=language-rust data-lang=rust><span style=font-style:italic;color:#c792ea>fn </span><span style=color:#82aaff>main</span><span style=color:#89ddff>() {
</span><span>    </span><span style=font-style:italic;color:#c792ea>let </span><span style=color:#89ddff>(</span><span>producer</span><span style=color:#89ddff>,</span><span> consumer</span><span style=color:#89ddff>) = </span><span style=color:#82aaff>buffered_queue</span><span style=color:#89ddff>(</span><span style=color:#f78c6c>3</span><span style=color:#89ddff>);
</span><span>    </span><span style=font-style:italic;color:#c792ea>let </span><span style=color:#c792ea>mut</span><span> output </span><span style=color:#89ddff>= </span><span style=color:#ffcb6b>Vec</span><span style=color:#89ddff>::</span><span>new</span><span style=color:#89ddff>();
</span><span>
</span><span>    </span><span style=font-style:italic;color:#c792ea>let</span><span> producer_handle </span><span style=color:#89ddff>= </span><span>thread</span><span style=color:#89ddff>::</span><span>spawn</span><span style=color:#89ddff>(</span><span style=color:#c792ea>move </span><span style=color:#89ddff>|| {
</span><span>        println!</span><span style=color:#89ddff>("</span><span style=color:#c3e88d>initializing producer thread...</span><span style=color:#89ddff>");
</span><span>
</span><span>        </span><span style=font-style:italic;color:#c792ea>for</span><span> num </span><span style=color:#89ddff>in </span><span style=color:#f78c6c>1</span><span style=color:#89ddff>..=</span><span style=color:#f78c6c>5 </span><span style=color:#89ddff>{
</span><span>            </span><span style=font-style:italic;color:#c792ea>let</span><span> processed_num </span><span style=color:#89ddff>=</span><span> num </span><span style=color:#89ddff>*</span><span> num </span><span style=color:#89ddff>*</span><span> num</span><span style=color:#89ddff>;
</span><span>
</span><span>            </span><span style=font-style:italic;color:#4a4a4a>// mock processing behaviour
</span><span>            </span><span style=color:#82aaff>sleep</span><span style=color:#89ddff>(</span><span>Duration</span><span style=color:#89ddff>::</span><span>from_millis</span><span style=color:#89ddff>(</span><span style=color:#f78c6c>250</span><span style=color:#89ddff>));
</span><span>            producer</span><span style=color:#89ddff>.</span><span style=color:#82aaff>push</span><span style=color:#89ddff>(</span><span>processed_num</span><span style=color:#89ddff>);
</span><span>        </span><span style=color:#89ddff>}
</span><span>    </span><span style=color:#89ddff>});
</span><span>
</span><span>    </span><span style=font-style:italic;color:#c792ea>let</span><span> consumer_handle </span><span style=color:#89ddff>= </span><span>thread</span><span style=color:#89ddff>::</span><span>spawn</span><span style=color:#89ddff>(</span><span style=color:#c792ea>move </span><span style=color:#89ddff>|| {
</span><span>        println!</span><span style=color:#89ddff>("</span><span style=color:#c3e88d>initializing consumer thread...</span><span style=color:#89ddff>");
</span><span>
</span><span>        </span><span style=font-style:italic;color:#c792ea>loop </span><span style=color:#89ddff>{
</span><span>            </span><span style=font-style:italic;color:#c792ea>let </span><span style=color:#ffcb6b>Some</span><span style=color:#89ddff>(</span><span>num</span><span style=color:#89ddff>) =</span><span> consumer</span><span style=color:#89ddff>.</span><span style=color:#82aaff>pop</span><span style=color:#89ddff>() </span><span style=font-style:italic;color:#c792ea>else </span><span style=color:#89ddff>{
</span><span>                    println!</span><span style=color:#89ddff>("</span><span style=color:#c3e88d>exhausted queue, terminating consumer!</span><span style=color:#89ddff>\n");
</span><span>                    </span><span style=font-style:italic;color:#c792ea>return</span><span style=color:#89ddff>;
</span><span>            </span><span style=color:#89ddff>};
</span><span>
</span><span>            </span><span style=font-style:italic;color:#4a4a4a>// mock processing behaviour
</span><span>            </span><span style=color:#82aaff>sleep</span><span style=color:#89ddff>(</span><span>Duration</span><span style=color:#89ddff>::</span><span>from_millis</span><span style=color:#89ddff>(</span><span style=color:#f78c6c>400</span><span style=color:#89ddff>));
</span><span>            output</span><span style=color:#89ddff>.</span><span style=color:#82aaff>push</span><span style=color:#89ddff>(</span><span>num</span><span style=color:#89ddff>);
</span><span>
</span><span>            println!</span><span style=color:#89ddff>(
</span><span>                </span><span style=color:#89ddff>"</span><span style=color:#c3e88d>pushed to output num: </span><span>{}</span><span style=color:#c3e88d>; output_vec len: </span><span>{}</span><span style=color:#89ddff>",
</span><span>                num</span><span style=color:#89ddff>,
</span><span>                output</span><span style=color:#89ddff>.</span><span style=color:#82aaff>len</span><span style=color:#89ddff>()
</span><span>            </span><span style=color:#89ddff>);
</span><span>        </span><span style=color:#89ddff>}
</span><span>    </span><span style=color:#89ddff>});
</span><span>
</span><span>    producer_handle</span><span style=color:#89ddff>.</span><span style=color:#82aaff>join</span><span style=color:#89ddff>().</span><span style=color:#82aaff>unwrap</span><span style=color:#89ddff>();
</span><span>    consumer_handle</span><span style=color:#89ddff>.</span><span style=color:#82aaff>join</span><span style=color:#89ddff>().</span><span style=color:#82aaff>unwrap</span><span style=color:#89ddff>();
</span><span style=color:#89ddff>}
</span></code></pre><p>We initialize our <code>producer</code> and <code>consumer</code> values by calling <code>buffered_queue</code>, and create a vector for the output produced by the consumer thread.<p>Then we mark our threads with <code>move</code>, meaning they will take ownership of any values used inside them. We use closures to write the thread logic inside the <code>spawn</code> blocks.<p>The producer thread iterates over a range of numbers, mocking input processing flow and pushes values to the queue. Meanwhile, the consumer thread processes values received from the <code>pop</code> function, stopping when it receives <code>None</code>, which is the signal to terminate execution.  <p>Finally, we receive return values of type <a href=https://doc.rust-lang.org/std/thread/struct.JoinHandle.html title=https://doc.rust-lang.org/std/thread/struct.JoinHandle.html>JoinHandle</a> from the spawned threads and call <code>join</code> on them in the main thread. This ensures that it waits for the other threads to finish before exiting. The <code>unwrap</code> call will propagate any runtime errors in these threads to the main thread.<p>Running <code>cargo run</code> will output the following:<pre class=language-plaintext data-lang=plaintext style=background:#212121;color:#eeffff><code class=language-plaintext data-lang=plaintext><span>initializing consumer thread...
</span><span>initializing producer thread...
</span><span>pushed element
</span><span>set is_empty to false
</span><span>popped element
</span><span>set is_empty to true
</span><span>pushed element
</span><span>set is_empty to false
</span><span>pushed to output num: 1; output_vec len: 1
</span><span>popped element
</span><span>set is_empty to true
</span><span>pushed element
</span><span>set is_empty to false
</span><span>pushed element
</span><span>pushed to output num: 8; output_vec len: 2
</span><span>popped element
</span><span>pushed element
</span><span>pushed to output num: 27; output_vec len: 3
</span><span>popped element
</span><span>pushed to output num: 64; output_vec len: 4
</span><span>popped element
</span><span>set is_empty to true
</span><span>pushed to output num: 125; output_vec len: 5
</span><span>exhausted queue, terminating consumer!
</span></code></pre><h2 id=conclusion>Conclusion</h2><p>This was a rewarding exercise for me, as it helped me get more familiar with Rust and concurrency concepts in general. You can find the full code for the exercise <a href=https://github.com/dhruv-ahuja/buffered-queue-rs title=https://github.com/dhruv-ahuja/buffered-queue-rs>here</a>, there are some differences in the code shown here and in the repo.<p>Thanks for reading my post, any feedback or advice would be appreciated! You can write to me at <a href=mailto:dhruvahuja2k@gmail.com title=mailto:dhruvahuja2k@gmail.com>my email</a>.</section></article></main></div></body><footer><p>Made with <a href=https://www.getzola.org/ target=_blank>Zola</a>, using a <a href=https://github.com/dhruv-ahuja/apollo-custom target=_blank>custom variant</a> of the <a href=https://github.com/not-matthias/apollo target=_blank>Apollo</a> theme.</footer>